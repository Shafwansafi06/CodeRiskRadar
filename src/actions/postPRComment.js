/**
 * Rovo Action: Post PR Comment
 * 
 * Posts risk analysis as a comment on a pull request.
 * Implements dry-run pattern: returns preview first, requires confirm=true to execute.
 */

const api = require('@forge/api');
const fetch = require('node-fetch');

/**
 * Example Input JSON:
 * {
 *   "risk_analysis": {
 *     "explanation": "Critical SQL injection vulnerability detected",
 *     "risk_level": "critical",
 *     "actions": [...]
 *   },
 *   "pr_number": "123",
 *   "repository": "company/code-risk-radar",
 *   "confirm": false
 * }
 * 
 * Example Output JSON (preview):
 * {
 *   "preview": "# ðŸš¨ Code Risk Radar Analysis\n\n**Risk Level:** CRITICAL\n\n...",
 *   "comment_id": null,
 *   "comment_url": null,
 *   "requires_confirmation": true
 * }
 * 
 * Example Output JSON (confirmed):
 * {
 *   "preview": null,
 *   "comment_id": "987654321",
 *   "comment_url": "https://github.com/company/repo/pull/123#issuecomment-987654321",
 *   "requires_confirmation": false,
 *   "posted": true
 * }
 */

/**
 * Build PR comment markdown from risk analysis
 */
function buildCommentMarkdown(riskAnalysis, metadata = {}) {
  const riskLevel = riskAnalysis.risk_level || 'medium';
  
  // Risk level emoji and styling
  const riskEmoji = {
    critical: 'ðŸš¨',
    high: 'ðŸ”´',
    medium: 'âš ï¸',
    low: 'âœ…'
  };
  
  const emoji = riskEmoji[riskLevel] || 'â“';
  
  let comment = `# ${emoji} Code Risk Radar Analysis\n\n`;
  
  // Risk level badge
  const badgeColor = {
    critical: 'critical',
    high: 'important',
    medium: 'yellow',
    low: 'success'
  }[riskLevel] || 'inactive';
  
  comment += `![Risk Level](https://img.shields.io/badge/Risk_Level-${riskLevel.toUpperCase()}-${badgeColor}?style=for-the-badge)\n\n`;
  
  // Risk score if available
  if (metadata.risk_score !== undefined) {
    const scorePercent = (metadata.risk_score * 100).toFixed(1);
    comment += `**Risk Score:** ${scorePercent}% / 100%\n\n`;
  }
  
  // Explanation
  comment += `## ðŸ“Š Analysis\n\n`;
  comment += `${riskAnalysis.explanation}\n\n`;
  
  // File context
  if (metadata.file_path) {
    comment += `**File:** \`${metadata.file_path}\`\n\n`;
  }
  
  // Top risk features
  if (metadata.top_features && metadata.top_features.length > 0) {
    comment += `### ðŸŽ¯ Top Risk Factors\n\n`;
    metadata.top_features.slice(0, 5).forEach((feature, idx) => {
      const importance = (feature.importance * 100).toFixed(1);
      const bars = 'â–ˆ'.repeat(Math.ceil(feature.importance * 10));
      comment += `${idx + 1}. **${feature.name}**: ${importance}% ${bars}\n`;
    });
    comment += '\n';
  }
  
  // Actions
  if (riskAnalysis.actions && riskAnalysis.actions.length > 0) {
    comment += `## âœ… Recommended Actions\n\n`;
    
    // Group by priority
    const highPriority = riskAnalysis.actions.filter(a => a.priority === 'high');
    const mediumPriority = riskAnalysis.actions.filter(a => a.priority === 'medium');
    const lowPriority = riskAnalysis.actions.filter(a => a.priority === 'low');
    
    const renderActions = (actions, priorityLabel, priorityEmoji) => {
      if (actions.length === 0) return;
      
      comment += `### ${priorityEmoji} ${priorityLabel} Priority\n\n`;
      actions.forEach((action, idx) => {
        comment += `${idx + 1}. **[${action.type.toUpperCase()}]** ${action.description}\n`;
        comment += `   - â±ï¸ Effort: ${action.effort_estimate}\n`;
        comment += `   - ðŸŽ¯ Confidence: ${(action.confidence * 100).toFixed(0)}%\n`;
        
        if (action.evidence_lines && action.evidence_lines.length > 0) {
          comment += `   - ðŸ“ Evidence:\n`;
          action.evidence_lines.forEach(line => {
            comment += `     - \`${line}\`\n`;
          });
        }
        comment += '\n';
      });
    };
    
    renderActions(highPriority, 'High', 'ðŸ”´');
    renderActions(mediumPriority, 'Medium', 'ðŸŸ¡');
    renderActions(lowPriority, 'Low', 'ðŸŸ¢');
  }
  
  // Historical context
  if (metadata.historical_context) {
    comment += `## ðŸ“š Historical Context\n\n`;
    comment += `${metadata.historical_context}\n\n`;
  }
  
  // Footer
  comment += `---\n\n`;
  comment += `<sub>ðŸ¤– Generated by [Code Risk Radar](https://github.com/company/code-risk-radar) | `;
  comment += `Analyzed at ${new Date().toISOString()}</sub>\n`;
  
  return comment;
}

/**
 * Generate preview with safety warnings
 */
function generatePreview(commentMarkdown, repository, prNumber) {
  let preview = `ðŸ’¬ **PR Comment Preview**\n\n`;
  preview += `**Target:** ${repository}#${prNumber}\n`;
  preview += `**Length:** ${commentMarkdown.length} characters\n\n`;
  preview += `---\n\n`;
  preview += `${commentMarkdown}\n\n`;
  preview += `---\n\n`;
  preview += `âš ï¸ **This is a preview.** Set \`confirm=true\` to post the comment.\n`;
  
  return preview;
}

/**
 * Validate input parameters
 */
function validateInput(input) {
  const errors = [];
  
  if (!input.risk_analysis) {
    errors.push('risk_analysis is required');
  } else {
    if (typeof input.risk_analysis === 'string') {
      try {
        input.risk_analysis = JSON.parse(input.risk_analysis);
      } catch (e) {
        errors.push('risk_analysis must be valid JSON');
      }
    }
  }
  
  if (!input.pr_number) {
    errors.push('pr_number is required');
  } else if (!/^\d+$/.test(String(input.pr_number))) {
    errors.push('pr_number must be a number');
  }
  
  if (!input.repository) {
    errors.push('repository is required');
  } else if (!/^[\w.-]+\/[\w.-]+$/.test(input.repository)) {
    errors.push('repository must be in format "owner/repo"');
  }
  
  return errors;
}

/**
 * Get GitHub API credentials from environment/storage
 */
async function getGitHubCredentials() {
  // Try environment variables first
  const token = process.env.GITHUB_TOKEN;
  if (token) {
    return { token };
  }
  
  // Try Forge storage
  try {
    const { storage } = require('@forge/api');
    const credentials = await storage.get('github_credentials');
    if (credentials && credentials.token) {
      return credentials;
    }
  } catch (error) {
    console.error('Failed to retrieve GitHub credentials:', error);
  }
  
  throw new Error('GitHub credentials not configured. Set GITHUB_TOKEN environment variable or store in Forge storage.');
}

/**
 * Post comment to GitHub PR
 */
async function postGitHubComment(repository, prNumber, commentBody, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments`;
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      'Authorization': `token ${credentials.token}`,
      'Content-Type': 'application/json',
      'User-Agent': 'Code-Risk-Radar-Bot'
    },
    body: JSON.stringify({
      body: commentBody
    })
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
  }
  
  return await response.json();
}

/**
 * Check if we already commented on this PR
 */
async function findExistingComment(repository, prNumber, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/comments`;
  
  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': `token ${credentials.token}`,
        'User-Agent': 'Code-Risk-Radar-Bot'
      }
    });
    
    if (!response.ok) return null;
    
    const comments = await response.json();
    const botComment = comments.find(c => 
      c.body && c.body.includes('Code Risk Radar Analysis')
    );
    
    return botComment;
  } catch (error) {
    console.error('Failed to check existing comments:', error);
    return null;
  }
}

/**
 * Update existing comment
 */
async function updateGitHubComment(repository, commentId, commentBody, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/comments/${commentId}`;
  
  const response = await fetch(url, {
    method: 'PATCH',
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      'Authorization': `token ${credentials.token}`,
      'Content-Type': 'application/json',
      'User-Agent': 'Code-Risk-Radar-Bot'
    },
    body: JSON.stringify({
      body: commentBody
    })
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
  }
  
  return await response.json();
}

/**
 * Main action handler
 */
async function postPRCommentHandler(input) {
  console.log('postPRCommentHandler invoked', {
    repository: input.repository,
    pr_number: input.pr_number,
    confirm: input.confirm
  });
  
  // Validate input
  const validationErrors = validateInput(input);
  if (validationErrors.length > 0) {
    return {
      success: false,
      error: validationErrors.join('; '),
      preview: null,
      comment_id: null,
      comment_url: null
    };
  }
  
  const {
    risk_analysis,
    pr_number,
    repository,
    confirm = false,
    metadata = {},
    update_if_exists = true
  } = input;
  
  // Build comment
  let commentMarkdown;
  try {
    commentMarkdown = buildCommentMarkdown(risk_analysis, metadata);
  } catch (error) {
    console.error('Failed to build comment:', error);
    return {
      success: false,
      error: `Failed to build comment: ${error.message}`,
      preview: null,
      comment_id: null,
      comment_url: null
    };
  }
  
  // DRY RUN: Return preview
  if (!confirm) {
    console.log('Returning preview (confirm=false)');
    return {
      success: true,
      preview: generatePreview(commentMarkdown, repository, pr_number),
      comment_id: null,
      comment_url: null,
      requires_confirmation: true,
      comment_length: commentMarkdown.length
    };
  }
  
  // CONFIRMED: Post the comment
  console.log('Posting PR comment (confirm=true)');
  
  try {
    // Get credentials
    const credentials = await getGitHubCredentials();
    
    // Check if we already commented
    let result;
    if (update_if_exists) {
      const existingComment = await findExistingComment(repository, pr_number, credentials);
      
      if (existingComment) {
        console.log(`Updating existing comment ${existingComment.id}`);
        result = await updateGitHubComment(repository, existingComment.id, commentMarkdown, credentials);
        result.updated = true;
      }
    }
    
    // Post new comment if no existing one
    if (!result) {
      console.log('Posting new comment');
      result = await postGitHubComment(repository, pr_number, commentMarkdown, credentials);
      result.updated = false;
    }
    
    console.log('PR comment posted successfully:', result.id);
    
    // Log to audit trail
    await logAuditEvent({
      action: 'post_pr_comment',
      repository,
      pr_number,
      comment_id: result.id,
      risk_level: risk_analysis.risk_level,
      updated: result.updated
    });
    
    return {
      success: true,
      preview: null,
      comment_id: String(result.id),
      comment_url: result.html_url,
      requires_confirmation: false,
      posted: true,
      updated: result.updated
    };
  } catch (error) {
    console.error('Failed to post PR comment:', error);
    return {
      success: false,
      error: error.message,
      preview: null,
      comment_id: null,
      comment_url: null
    };
  }
}

/**
 * Log audit event
 */
async function logAuditEvent(event) {
  try {
    const { storage } = require('@forge/api');
    const auditLog = await storage.get('audit_log') || [];
    
    auditLog.push({
      ...event,
      timestamp: new Date().toISOString(),
      user: 'system'
    });
    
    if (auditLog.length > 1000) {
      auditLog.shift();
    }
    
    await storage.set('audit_log', auditLog);
  } catch (error) {
    console.error('Failed to log audit event:', error);
  }
}

module.exports = {
  postPRCommentHandler,
  buildCommentMarkdown,
  generatePreview,
  validateInput
};
