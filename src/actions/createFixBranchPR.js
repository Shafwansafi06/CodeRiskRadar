/**
 * Rovo Action: Create Fix Branch PR
 * 
 * Creates a fix branch and pull request based on risk analysis.
 * MANUAL CONFIRMATION REQUIRED: This action always requires explicit confirm=true.
 */

const fetch = require('node-fetch');

/**
 * Example Input JSON:
 * {
 *   "risk_analysis": {
 *     "explanation": "Critical SQL injection vulnerability detected",
 *     "risk_level": "critical",
 *     "actions": [...]
 *   },
 *   "base_branch": "main",
 *   "fix_description": "Implement parameterized queries to prevent SQL injection",
 *   "repository": "company/code-risk-radar",
 *   "confirm": true  // MUST be explicitly set to true
 * }
 * 
 * Example Output JSON (preview - confirm not set):
 * {
 *   "preview": "üîß Fix Branch & PR Preview\n\n...",
 *   "branch_name": null,
 *   "pr_number": null,
 *   "pr_url": null,
 *   "requires_confirmation": true,
 *   "warning": "This action requires explicit manual confirmation"
 * }
 * 
 * Example Output JSON (confirmed):
 * {
 *   "preview": null,
 *   "branch_name": "fix/risk-critical-sql-injection-1234567890",
 *   "pr_number": "456",
 *   "pr_url": "https://github.com/company/repo/pull/456",
 *   "requires_confirmation": false,
 *   "created": true
 * }
 */

/**
 * Generate branch name from risk analysis
 */
function generateBranchName(riskAnalysis) {
  const riskLevel = riskAnalysis.risk_level || 'medium';
  const timestamp = Date.now();
  
  // Extract key words from explanation
  const explanation = riskAnalysis.explanation.toLowerCase();
  const keywords = explanation
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter(word => word.length > 3)
    .slice(0, 3)
    .join('-');
  
  return `fix/risk-${riskLevel}-${keywords}-${timestamp}`.substring(0, 80);
}

/**
 * Build PR title and body
 */
function buildPRContent(riskAnalysis, fixDescription, metadata = {}) {
  const riskLevel = riskAnalysis.risk_level || 'medium';
  
  // Title
  const title = `üîß [${riskLevel.toUpperCase()}] Fix: ${fixDescription.substring(0, 80)}`;
  
  // Body
  let body = `## üö® Automated Fix for Risk Detection\n\n`;
  body += `This PR addresses a **${riskLevel}** risk level issue identified by Code Risk Radar.\n\n`;
  
  body += `### üìä Risk Analysis\n\n`;
  body += `${riskAnalysis.explanation}\n\n`;
  
  if (metadata.file_path) {
    body += `**Affected File:** \`${metadata.file_path}\`\n\n`;
  }
  
  if (metadata.risk_score !== undefined) {
    body += `**Risk Score:** ${(metadata.risk_score * 100).toFixed(1)}%\n\n`;
  }
  
  body += `### üîß Proposed Fix\n\n`;
  body += `${fixDescription}\n\n`;
  
  // Actions checklist
  if (riskAnalysis.actions && riskAnalysis.actions.length > 0) {
    body += `### ‚úÖ Remediation Checklist\n\n`;
    riskAnalysis.actions.forEach((action, idx) => {
      body += `- [ ] **[${action.type.toUpperCase()}]** ${action.description}\n`;
      body += `  - Effort: ${action.effort_estimate} | Confidence: ${(action.confidence * 100).toFixed(0)}%\n`;
    });
    body += '\n';
  }
  
  body += `### üß™ Testing\n\n`;
  body += `- [ ] Unit tests pass\n`;
  body += `- [ ] Integration tests pass\n`;
  body += `- [ ] Security scan passes\n`;
  body += `- [ ] Manual testing completed\n\n`;
  
  body += `### üìö References\n\n`;
  if (metadata.original_pr) {
    body += `- Original PR: #${metadata.original_pr}\n`;
  }
  if (metadata.jira_task) {
    body += `- Jira Task: ${metadata.jira_task}\n`;
  }
  
  body += `\n---\n\n`;
  body += `ü§ñ **This PR was automatically generated by Code Risk Radar**\n`;
  body += `‚ö†Ô∏è **Please review carefully before merging**\n\n`;
  body += `<sub>Generated at ${new Date().toISOString()}</sub>\n`;
  
  return { title, body };
}

/**
 * Generate preview
 */
function generatePreview(branchName, prContent, repository, baseBranch) {
  let preview = `üîß **Fix Branch & PR Preview**\n\n`;
  preview += `‚ö†Ô∏è **WARNING: This action will create a new branch and PR in your repository.**\n\n`;
  preview += `**Repository:** ${repository}\n`;
  preview += `**Base Branch:** ${baseBranch}\n`;
  preview += `**New Branch:** \`${branchName}\`\n\n`;
  preview += `---\n\n`;
  preview += `### PR Title\n${prContent.title}\n\n`;
  preview += `### PR Body\n${prContent.body}\n\n`;
  preview += `---\n\n`;
  preview += `üö® **MANUAL CONFIRMATION REQUIRED**\n\n`;
  preview += `To create this branch and PR, you MUST:\n`;
  preview += `1. Review the preview above carefully\n`;
  preview += `2. Set \`confirm=true\` explicitly\n`;
  preview += `3. Ensure you have the necessary permissions\n\n`;
  preview += `**This is a write operation and cannot be easily undone.**\n`;
  
  return preview;
}

/**
 * Validate input parameters
 */
function validateInput(input) {
  const errors = [];
  
  if (!input.risk_analysis) {
    errors.push('risk_analysis is required');
  } else {
    if (typeof input.risk_analysis === 'string') {
      try {
        input.risk_analysis = JSON.parse(input.risk_analysis);
      } catch (e) {
        errors.push('risk_analysis must be valid JSON');
      }
    }
  }
  
  if (!input.base_branch) {
    errors.push('base_branch is required');
  } else if (!/^[\w.-\/]+$/.test(input.base_branch)) {
    errors.push('base_branch contains invalid characters');
  }
  
  if (!input.fix_description) {
    errors.push('fix_description is required');
  } else if (input.fix_description.length < 10) {
    errors.push('fix_description must be at least 10 characters');
  }
  
  if (!input.repository) {
    errors.push('repository is required');
  } else if (!/^[\w.-]+\/[\w.-]+$/.test(input.repository)) {
    errors.push('repository must be in format "owner/repo"');
  }
  
  // CRITICAL: confirm must be explicitly true (not just truthy)
  if (input.confirm !== true) {
    errors.push('confirm must be explicitly set to true (manual confirmation required)');
  }
  
  return errors;
}

/**
 * Get GitHub API credentials
 */
async function getGitHubCredentials() {
  const token = process.env.GITHUB_TOKEN;
  if (token) {
    return { token };
  }
  
  try {
    const { storage } = require('@forge/api');
    const credentials = await storage.get('github_credentials');
    if (credentials && credentials.token) {
      return credentials;
    }
  } catch (error) {
    console.error('Failed to retrieve GitHub credentials:', error);
  }
  
  throw new Error('GitHub credentials not configured');
}

/**
 * Get the SHA of the base branch
 */
async function getBranchSHA(repository, branch, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/git/refs/heads/${branch}`;
  
  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      'Authorization': `token ${credentials.token}`,
      'User-Agent': 'Code-Risk-Radar-Bot'
    }
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to get branch SHA: ${response.status} - ${errorText}`);
  }
  
  const data = await response.json();
  return data.object.sha;
}

/**
 * Create a new branch
 */
async function createBranch(repository, branchName, sha, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/git/refs`;
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      'Authorization': `token ${credentials.token}`,
      'Content-Type': 'application/json',
      'User-Agent': 'Code-Risk-Radar-Bot'
    },
    body: JSON.stringify({
      ref: `refs/heads/${branchName}`,
      sha: sha
    })
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to create branch: ${response.status} - ${errorText}`);
  }
  
  return await response.json();
}

/**
 * Create a pull request
 */
async function createPullRequest(repository, title, body, head, base, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/pulls`;
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Accept': 'application/vnd.github.v3+json',
      'Authorization': `token ${credentials.token}`,
      'Content-Type': 'application/json',
      'User-Agent': 'Code-Risk-Radar-Bot'
    },
    body: JSON.stringify({
      title,
      body,
      head,
      base,
      draft: true, // Create as draft by default for safety
      maintainer_can_modify: true
    })
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to create PR: ${response.status} - ${errorText}`);
  }
  
  return await response.json();
}

/**
 * Add labels to PR
 */
async function addLabelsToPR(repository, prNumber, labels, credentials) {
  const [owner, repo] = repository.split('/');
  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/labels`;
  
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': `token ${credentials.token}`,
        'Content-Type': 'application/json',
        'User-Agent': 'Code-Risk-Radar-Bot'
      },
      body: JSON.stringify({
        labels
      })
    });
    
    if (!response.ok) {
      console.warn('Failed to add labels to PR');
    }
  } catch (error) {
    console.error('Error adding labels:', error);
  }
}

/**
 * Main action handler
 */
async function createFixBranchPRHandler(input) {
  console.log('createFixBranchPRHandler invoked', {
    repository: input.repository,
    base_branch: input.base_branch,
    confirm: input.confirm
  });
  
  // Validate input (includes confirm check)
  const validationErrors = validateInput(input);
  if (validationErrors.length > 0) {
    console.log('Validation failed:', validationErrors);
    
    // If only error is confirm, provide preview
    if (validationErrors.length === 1 && validationErrors[0].includes('confirm')) {
      try {
        const branchName = generateBranchName(input.risk_analysis);
        const prContent = buildPRContent(
          input.risk_analysis, 
          input.fix_description, 
          input.metadata || {}
        );
        
        return {
          success: true,
          preview: generatePreview(branchName, prContent, input.repository, input.base_branch),
          branch_name: null,
          pr_number: null,
          pr_url: null,
          requires_confirmation: true,
          warning: 'This action requires explicit manual confirmation (confirm=true)'
        };
      } catch (error) {
        return {
          success: false,
          error: `Preview generation failed: ${error.message}`,
          preview: null,
          branch_name: null,
          pr_number: null,
          pr_url: null
        };
      }
    }
    
    return {
      success: false,
      error: validationErrors.join('; '),
      preview: null,
      branch_name: null,
      pr_number: null,
      pr_url: null
    };
  }
  
  const {
    risk_analysis,
    base_branch,
    fix_description,
    repository,
    metadata = {}
  } = input;
  
  // CONFIRMED: Create branch and PR
  console.log('Creating fix branch and PR (confirm=true)');
  
  try {
    // Get credentials
    const credentials = await getGitHubCredentials();
    
    // Generate branch name
    const branchName = generateBranchName(risk_analysis);
    console.log('Generated branch name:', branchName);
    
    // Build PR content
    const prContent = buildPRContent(risk_analysis, fix_description, metadata);
    
    // Get base branch SHA
    console.log(`Getting SHA for base branch: ${base_branch}`);
    const baseSHA = await getBranchSHA(repository, base_branch, credentials);
    
    // Create new branch
    console.log(`Creating branch: ${branchName}`);
    await createBranch(repository, branchName, baseSHA, credentials);
    
    // Create pull request
    console.log('Creating pull request');
    const pr = await createPullRequest(
      repository,
      prContent.title,
      prContent.body,
      branchName,
      base_branch,
      credentials
    );
    
    console.log(`PR created successfully: #${pr.number}`);
    
    // Add labels
    const labels = [
      'automated-fix',
      'code-risk-radar',
      `risk-${risk_analysis.risk_level}`
    ];
    
    await addLabelsToPR(repository, pr.number, labels, credentials);
    
    // Log to audit trail
    await logAuditEvent({
      action: 'create_fix_branch_pr',
      repository,
      base_branch,
      branch_name: branchName,
      pr_number: pr.number,
      risk_level: risk_analysis.risk_level,
      metadata
    });
    
    return {
      success: true,
      preview: null,
      branch_name: branchName,
      pr_number: String(pr.number),
      pr_url: pr.html_url,
      requires_confirmation: false,
      created: true,
      draft: true
    };
  } catch (error) {
    console.error('Failed to create fix branch and PR:', error);
    return {
      success: false,
      error: error.message,
      preview: null,
      branch_name: null,
      pr_number: null,
      pr_url: null
    };
  }
}

/**
 * Log audit event
 */
async function logAuditEvent(event) {
  try {
    const { storage } = require('@forge/api');
    const auditLog = await storage.get('audit_log') || [];
    
    auditLog.push({
      ...event,
      timestamp: new Date().toISOString(),
      user: 'system'
    });
    
    if (auditLog.length > 1000) {
      auditLog.shift();
    }
    
    await storage.set('audit_log', auditLog);
  } catch (error) {
    console.error('Failed to log audit event:', error);
  }
}

module.exports = {
  createFixBranchPRHandler,
  generateBranchName,
  buildPRContent,
  generatePreview,
  validateInput
};
